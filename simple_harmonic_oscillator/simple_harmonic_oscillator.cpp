#include<iostream>
#include<fstream>
#include<iomanip>
#include<cmath>
#include<ctime>
#include<complex>

using namespace std;

const int N = 8; //matrix size
const int ntau = 20; //total steps in leap frog
const double dtau = 0.2; //step increment in leap frog

int box_muller(double &p, double &q){
    //box muller algorithm for creating random numbers p and q with gaussian weights
    double r, s;
    r = (double)rand()/RAND_MAX;
    s = (double)rand()/RAND_MAX;
    p = sqrt(-2*log(r))*sin(2*M_PI*s);
    q = sqrt(-2*log(r))*cos(2*M_PI*s);
    return 0;
}

double action(const complex<double> phi[N][N]){
    complex<double> phi2[N][N];
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++){
            for(int k=0; k<N; k++){
                phi2[i][j] += phi[i][k]*phi[k][j]; //calculates phi^2 matrix
            }
        }
    }
    double action = 0;
    for(int i=0; i<N; i++){
        action += 0.5*real(phi2[i][i]);  //trace of phi^2
    }
    return action*((double)N);
}

double hamiltonian(const complex<double> phi[N][N], const complex<double> P[N][N]){
    double hmltn;
    complex<double> store;
    hmltn = action(phi);
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++){
            store = P[i][j]*P[j][i];
            hmltn += .5*real(store); // calculates P^2 matrix and the trace
        }
    }
    return hmltn/((double)N*N);
}

int force(complex<double> (&delh)[N][N], const complex<double> phi[N][N]){
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++){
            delh[i][j] = phi[i][j]; // dH/dphi = d/dphi (.5*phi^2) = phi
         }
    }
    return 0;
}

int Molecular_Dynamcis(complex<double> phi[N][N], double &hmltn_i, double &hmltn_f, int ntau){
    //update mechanism. Only phi is the input. Rest of the arguments are passed as references to be used in int main() function.
    //trp and tr are the traces of phi and P matrices respectively
    complex<double> delh[N][N];
    complex<double> P[N][N];
    double r1, r2;
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++){
            box_muller(r1, r2);
            P[i][j] = r1/sqrt(2) + r2/sqrt(2)*complex<double>(0, 1);
            P[j][i] = r1/sqrt(2) - r2/sqrt(2)*complex<double>(0, 1); //initialization of P matrix using random numbers generated by box muller
        }
    }
    for(int i=0; i<N; i++){
        box_muller(r1, r2);
        P[i][i] = r1;
    }
    hmltn_i = hamiltonian(phi, P);
    //first step of the leap frog method
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++){
            phi[i][j] += P[i][j]*.5*dtau;
        }
    }
    //intermediate steps
    for(int step=1; step<ntau; step++){
        force(delh, phi);
        for(int i=0; i<N; i++){
            for(int j=0; j<N; j++){
                P[i][j] -= delh[i][j]*dtau;
                phi[i][j] += P[i][j]*dtau;
            }
        }
    }
    force(delh, phi);
    //final step
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++){
            P[i][j] -= delh[i][j]*dtau;
            phi[i][j] += P[i][j]*.5*dtau;
        }
    }
    hmltn_f = hamiltonian(phi, P);
    return 0;
}

int main(){
    complex<double> phi[N][N];
    complex<double> backup_phi[N][N];
    double hmltn_i, hmltn_f, metropolis;
    srand((unsigned)time(NULL));
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++){
            phi[i][j] = complex<double>(0.0, 0.0);  //initialization of the phi matrix
        }
    }
    int naccept = 0;
    double sum = 0;
    ofstream fout("newdata.txt", ios::app); //to append the file for different outputs for varying matrix sizes.
    //We will run the code for one matrix size, append the output and run the code again for a different matrix size and repeat.
    for(int iter=0; iter<10000; iter++){ //number of iterations
        for(int i=0; i<N; i++){
            for(int j=0; j<N; j++){
                backup_phi[i][j] = phi[i][j]; //initialization of the backup phi matrix
            }
        }
        Molecular_Dynamcis(phi, hmltn_i, hmltn_f, ntau);
        metropolis = (double)rand()/RAND_MAX;
        if(exp(hmltn_i-hmltn_f) > metropolis){  //metropolis test
            naccept = naccept + 1; //accepted
        }
        else{
            for(int i=0; i<N; i++){
                for(int j=0; j<N; j++){
                    phi[i][j] = backup_phi[i][j];  //rejected
                }
            }
        }
        sum += action(phi);
        cout << naccept/((double)(iter+1)) << endl; //acceptance rate
        if(iter == 9999){
            //Only the final iteration will be printed out in the data file for each matrix dimension.
            //Then we use variance = <E^2> - <E>^2
            fout << fixed << setprecision(3) << N << "        " <<
                (sum*sum)/((double)(iter+1)*N*N*N*N) - pow((sum)/((double)(iter+1)*N*N), 2) << endl;
            cout << (sum*sum)/((double)(iter+1)*N*N*N*N) - pow((sum)/((double)(iter+1)*N*N), 2) << endl;
        }
    }
    return 0;
}
